# Git 分支合并操作完全手册

## 1. 核心理念

在团队协作中，保持主分支（如 `main` 或 `master`）的稳定和清晰至关重要。同时，开发分支需要定期与主分支同步，以获取最新的代码更新，避免偏离过远。

本文档旨在提供一套规范、安全、高效的 Git 分支合并与同步策略。

## 2. 两大核心策略：`Merge` vs `Rebase`

将一个分支的更改合入另一个分支，主要有两种方法：`git merge` 和 `git rebase`。

### 2.1. `git merge` (合并)

- **工作方式:** 创建一个新的“合并提交”，将两个分支的历史连接在一起。
- **优点:**
    - **保留完整的历史记录:** 能真实地反映出分支的创建和合并历史。
    - **非破坏性操作:** 不会修改已有的提交。
- **缺点:**
    - **复杂的历史线:** 如果频繁合并，会导致提交历史图谱变得非常复杂，难以阅读。
- **适用场景:**
    - 将功能分支最终合并回主分支（如 `main`）。
    - 团队规定需要保留所有分支的合并记录。

**基本操作:**
```shell
# 切换到接收更新的分支 (例如 main)
git checkout main

# 合并来源分支 (例如 feature/my-feature)
git merge feature/my-feature
```

### 2.2. `git rebase` (变基)

- **工作方式:** 将你的分支的提交“重新”在目标分支的最新提交之上逐个应用，形成一条线性的历史记录。
- **优点:**
    - **清晰的线性历史:** 提交历史像一条直线，非常易于阅读和理解。
    - **没有无意义的合并提交。**
- **缺点:**
    - **修改了提交历史:** `rebase` 会创建新的提交（具有不同的 SHA-1 值），这对于已经推送到远程的公共分支是危险的。
- **适用场景:**
    - **开发分支同步主分支的更新。** (这是最常见的场景，也是我们本次操作的场景)
    - 在将功能分支合并到 `main` 之前，整理该分支的提交历史。

**基本操作:**
```shell
# 切换到需要更新的开发分支
git checkout feature/my-feature

# 将当前分支变基到 main 分支上
git rebase main
```

**黄金法则:** **永远不要对已经推送到远程并被他人使用的公共分支（如 `main`）执行 `rebase` 操作。**

## 3. 常见问题与解决方案 (踩坑点)

### 3.1. 问题：`rebase` 或 `merge` 前工作区不干净

- **现象:** 执行命令时，提示 `error: cannot rebase: You have unstaged changes.` 或类似的错误。
- **原因:** Git 要求在执行这些重要操作前，你的工作目录是干净的，以防止你的本地修改丢失。
- **解决方案:** 使用 `git stash`。
    ```shell
    # 1. 暂存你的本地修改
    git stash

    # 2. 执行 rebase 或 merge 操作
    git rebase main

    # 3. 操作成功后，恢复你的修改
    git stash pop
    ```

### 3.2. 问题：操作过程中发生冲突 (Conflict)

- **现象:** `rebase` 或 `merge` 过程暂停，提示 `CONFLICT (content): Merge conflict in <file>...`
- **原因:** 两个分支修改了同一个文件的相同部分，Git 不知道该如何取舍。
- **解决方案：手动解决冲突**
    1.  **定位冲突文件:** Git 会在提示信息中列出所有冲突的文件。
    2.  **编辑文件:** 打开冲突文件，你会看到类似下面的冲突标记：
        ```
        <<<<<<< HEAD
        这是你当前分支的修改
        =======
        这是你正在合并/变基的分支的修改
        >>>>>>> commit-hash...
        ```
    3.  **解决冲突:** 根据你的需求，手动编辑这部分代码，删除冲突标记 (`<<<<<<<`, `=======`, `>>>>>>>`)，保留你想要最终呈现的代码。
    4.  **标记为已解决:** 使用 `git add` 将解决后的文件标记为已解决。
        ```shell
        git add <path/to/resolved/file.go>
        ```
    5.  **继续操作:**
        - 如果是 `rebase`: `git rebase --continue`
        - 如果是 `merge`: `git commit` (Git 会自动生成一个合并提交信息)

    **重要提示:**
    - **中止操作:** 如果在解决冲突时感到困惑，可以随时中止操作，回到开始之前的状态。
        - `git rebase --abort`
        - `git merge --abort`
    - **跳过提交 (`rebase` 独有):** 如果你认为某个提交是不必要的，或者它的修改已经被其他提交覆盖，你可以跳过它：`git rebase --skip`。**请谨慎使用此命令。**

### 3.3. 问题：`go.mod` / `go.sum` 或其他包管理文件冲突

- **现象:** `package.json`, `go.mod`, `pom.xml` 等依赖管理文件发生冲突。
- **原因:** 两个分支都修改了项目的依赖。
- **解决方案:**
    1.  **粗略解决:** 手动编辑文件，可以先选择接受其中一个分支的版本（通常是你的开发分支，因为它包含了新功能所需的依赖）。
    2.  **标记为已解决:** `git add go.mod go.sum`
    3.  **继续操作:** `git rebase --continue` 或 `git commit`
    4.  **最终整理:** 在整个 `rebase` 或 `merge` 过程**全部完成**后，运行项目对应的依赖整理命令。
        - **Go:** `go mod tidy`
        - **Node.js:** `npm install` 或 `yarn install`
        - **Maven:** `mvn install`

### 3.4. 问题：`cherry-pick` 遇到合并提交

- **现象:** `cherry-pick` 时提示 `is a merge but no -m option was given`。
- **原因:** `cherry-pick` 默认不知道如何处理一个有两个父提交的合并提交。
- **解决方案:**
    - **方案一 (不推荐):** 使用 `-m` 参数指定一个父提交。例如 `-m 1` 表示以第一个父提交为基准。但这通常会丢失合并的意义。
    - **方案二 (推荐):** 重新审视你的需求。如果你需要应用一个范围的提交，而这个范围里恰好有合并提交，那么 `rebase` 通常是更好的选择。

## 4. 最佳实践推荐

1.  **频繁同步:** 开发分支应该经常从主分支 `rebase` 最新的代码，而不是等到功能开发完成后再一次性同步。这可以减少每次 `rebase` 的冲突数量，让解决冲突变得更容易。
2.  **保持提交的原子性:** 每个提交应该只做一件事情，并有清晰的提交信息。这在 `rebase` 过程中非常有用，因为你可以清晰地知道每个提交的目的，从而更容易地解决冲突。
3.  **在 `push` 前 `rebase`:** 在将你的本地分支推送到远程之前，执行一次 `git rebase main`，这能确保你的分支在合入主分支时不会产生不必要的合并提交。
4.  **沟通:** 如果多人在同一个功能分支上协作，在有人执行了 `rebase` 并强制推送 (`push --force-with-lease`) 后，需要通知所有其他协作者。其他人需要使用 `git pull --rebase` 而不是 `git pull` 来同步代码。